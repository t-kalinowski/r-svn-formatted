\input texinfo
@c %**start of header
@setfilename R-data.info
@settitle R Data Import/Export
@setchapternewpage on
@c %**end of header

@syncodeindex fn vr

@dircategory Programming
@direntry
* R Data: (R-data).      R Data Import/Export
@end direntry

@finalout

@include R-defs.texi
@include version.texi

@ifinfo
This is a guide to importing and exporting data to and from R.

Copyright 2000 R Development Core Team

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore

@permission{}
@c ---------- ^- read that
@end ifinfo

@titlepage
@title R Data Import/Export
@subtitle Version @value{VERSION}
@author R Development Core Team
@page
@vskip 0pt plus 1filll
@permission{}

Copyright @copyright{} 2000 R Development Core Team
@end titlepage

@contents

@node Top, Introduction, (dir), (dir)

@menu
* Introduction::                
* Spreadsheet-like Data::       
* Importing from Other Statistical Systems::  
* Relational Databases::        
* Binary Files::                
* Network Connections::         
* References::                  
* Function and variable index::  
* Concept index::               
@end menu


@node Introduction, Spreadsheet-like Data, Top, Top
@chapter Introduction

Reading data into a statistical system for analysis and exporting the
results to some other system for report writing can be frustrating tasks
that can take far more time than the statistical analysis itself, even
though most readers will find the latter far more appealing.

This manual describes the import and export facilities available either
in @R{} itself or via packages which are available from CRAN.  Some of
the facilities described are still under development (and hence in the
Devel section on CRAN) but they already provide useful functionality.

Unless otherwise stated, everything described in this manual is
available for both Unix/Linux and Windows versions of @R{}.

In general statistical systems like @R{} are not particularly well
suited to manipulations of large-scale data.  Some other systems are
better than @R{} at this, and part of the thrust of this manual is to
suggest that rather than duplicating functionality in @R{} we can make
the other system do the work!  (For example Therneau & Grambsch (2000)
comment that they prefer to do data manipulation in SAS and then use
@pkg{survival5} in @Sl{} for the analysis.)  

@cindex Unix tools
@cindex AWK
@cindex Perl
It is also worth remembering that @R{} like @Sl{} comes from the Unix
tradition of small re-usable tools, and it can be rewarding to use tools
such as @code{awk} and @code{perl} to manipulate data before import or
before export. The case study in Becker, Chambers & Wilks (1988, Chapter
9) is an example of this, where Unix tools were used to check and
manipulate the data before input to @Sl{}.  @R{} itself takes that
approach, using @code{perl} to manipulate its databases of help files
rather than @R{} itself, and the function @code{read.fwf} used a call to
a @code{perl} script until it was decided not to require @code{perl} at
run-time.   The traditional Unix tools are now much more widely
available, including on Windows.



@menu
* Imports::                     
* Export to text files::        
@end menu

@node Imports, Export to text files, Introduction, Introduction
@section Imports
@findex scan

The easiest form of data to import into @R{} is a simple text file, and
this will often be acceptable for problems of small or medium scale.
The primary function to import from a text file is @code{scan}, and this
underlies most of the more convenient functions discussed in
@ref{Spreadsheet-like Data}.

However, all statistical consultants are familiar with being presented
by a client with a floppy disc or CD-R of data in some proprietary
binary format, for example `an Excel spreadsheet' or `an SPSS file'.
Often the simplest thing to do is to use the originating application to
export the data as a text file (and statistical consultants will have
copies of the commonest applications on their computers for that
purpose).  However, this is not always possible, and @ref{Importing from
Other Statistical Systems} discusses what facilities are available to
access such files directly from @R{}.

In a few cases, data have been stored in a binary form for compactness
and speed of access.  One application of this that we have seen several
times is imaging data, which is normally stored as a stream of bytes
as represented in memory, possibly preceded by a header.  Such data
formats are discussed in @ref{Binary Files}.

For much larger databases it is common to handle the data using a database
management system (DBMS).  There is once again the option of using the
DBMS to extract a plain file, but for many such DBMSs the extraction
operation can be done directly from an @R{} package: @xref{Relational
Databases}.  Importing data via network connections is discussed in 
@ref{Network Connections}.


@node Export to text files,  , Imports, Introduction
@section Export to text files
@cindex Exporting to a text file

Exporting results from @R{} is usually a less contentious task, but
there are still a number of pitfalls.  There will be a target
application in mind, and normally a text file will be the most
convenient interchange vehicle.  (If a binary file is required, see
@xref{Binary Files}.)

@findex cat
Function @code{cat} underlies the functions for exporting data.  It
takes a @code{file} argument, and the @code{append} argument allows a
text file to be written via successive calls to @code{cat}.

@findex write
@findex write.table
However, the commonest task is to write a matrix or data frame to file
as a rectangular grod of numbers, possibly with row and column labels.
This can be done by the functions @code{write.table} and @code{write}.
Function @code{write} just writes out a matrix or vector in a specified
number of columns (and transposes a matrix).  Function
@code{write.table} is more convenient, and writes out a data frame
(or an object that can be coerced to a data frame) with row and column
labels.

There are a number of issues that need to be considered in writing out a
data frame to a text file.

@enumerate
@findex format
@item @strong{Precision}

These functions are based on @code{cat} not @code{print}, and the
precision to which numbers are printed is governed by the
current setting of @code{options(digits)}.  It may be necessary
to increase this to avoid losing precision.  For more control,
use @code{format} on a data frame, possibly column-by-column.

@item @strong{Header line}

@R{} prefers the header line to have no entry for the row names, so the
file looks like
@smallexample
                dist    climb   time
Greenmantle     2.5     650     16.083
   ...
@end smallexample
Other systems require a (possibly empty) entry for the row names, which
is what @code{write.table} will provide if argument @code{col.names=NA}
is specified.  Excel is one such system.

@item @strong{Separator}
@cindex CSV files
@cindex comma separated values

A common field separator to use in the file is a comma, as that is
unlikely to appear in any of the fields, in English-speaking countries.
Such files are known as CSV (comma separated values) files.
Unfortunately, in some locales the comma is used as the decimal point
(set this in @code{write.table} by @code{dec=","}) and CSV files use
the semicolon as the field separator.

Using a semicolon or tab (@code{sep="\t"}) are probably the safest options.

@item @strong{Missing values}
@cindex missing values

By default missing values are output as @code{NA}, but this may be
changed by argument @code{na}.  Note that @code{NaN}s are treated as
@code{NA} by @code{write.table}, but not by @code{cat} nor @code{write}.

@item @strong{Quoting strings}
@cindex quoting strings

By default strings are quoted (including the row and column names).
Argument @code{quote} controls quoting of character variables.  Factors
are never quoted (and most character variables in data frames are factors).

Some care is needed if the strings contain embedded quotes.
@smallexample
> df <- data.frame(a = I("a \" quote"))
> write.table(df)
"a"
"1" "a " quote"
> write.table(df, quote=F)
a
1 a " quote
@end smallexample
@noindent
is much as one might expect, but is probably not acceptable to other
programs.  Better solutions include
@smallexample
> equote <- function(x) 
    if(is.character(x) gsub('"', '\\\\"', x)) else x
> write.table(lapply(df, equote))
"a"
"1" "a \" quote"
> dquote <- function(x) 
    if(is.character(x) gsub('"', '""', x)) else x
> write.table(lapply(df, dquote))
"a"
"1" "a "" quote"
@end smallexample
@noindent
the latter being the form of escape commonly used by spreadsheets.
@end enumerate

@findex sink
It is possible to use @code{sink} to divert the standard @R{} output
to a file, and thereby capture the output of (possibly implicit)
@code{print} statements.  This is not usually the most efficient route,
and the @code{options(width)} setting may need to be increased.


@node Spreadsheet-like Data, Importing from Other Statistical Systems, Introduction, Top
@chapter Spreadsheet-like Data
@cindex Spreadsheet-like data

@menu
* Variations on read.table::    
* Fixed-width-format files::    
* Using scan directly::         
* Re-shaping Data::             
@end menu

In @ref{Export to text files} we saw a number of variations on the
format of a spreadsheet-like text file, in which the data are presented
in a rectangular grid, possibly with row and column labels.  In this
section we consider importing such files into @R{}.

@node Variations on read.table, Fixed-width-format files, Spreadsheet-like Data, Spreadsheet-like Data
@section  Variations on @code{read.table}
@findex read.table

The function @code{read.table} is the most convenient way to read in
a rectangular grid of data.  Because of the many possibilities, there
are several other functions that call @code{read.table} but change a
group of default arguments.

Some of the issues to consider are:
@enumerate
@item @strong{Header line}

We recommend that you specify the @code{header} argument explicitly,
Conventionally the header line has entries only for the columns and not
for the row labels, so is one field shorter than the remaining lines.
(If @R{} sees this, it sets @code{header=TRUE}.)
If presented with a file that has a (possibly empty) header field for
the row labels, read it in by something like
@smallexample
read.table("file.dat", header=TRUE, row.names=1)
@end smallexample

Column names can be given explicitly via the @code{col.names};
explicit names override the header line (if present).

@item @strong{Separator}

Normally looking at the file will dictate the field separator to be
used, but with white-space separated files there may be a choice between
@code{sep=""} which uses any white space (spaces, tabs or newlines) as
a separator, @code{sep=" "} and @code{sep="\t"}. Note that the choice of
separator affects the input of quoted strings.

@item @strong{Quoting}
@cindex quoting strings

By default character strings can be quoted by either @code{""} or
@code{'}, and in each case all the characters up to a matching quote are
taken as part of the character string.  The set of valid quoting
characters (which might be none) is controlled by the @code{quote}
argument.  For @code{sep="\n"} the default is changed to @code{quote=""}.

If no separator character is specified, quotes can be escaped by 
immediately preceding them by @code{\}, C-style.

If a separator character is specified, quotes can be escaped by
doubling them as is conventional in spreadsheets.  For example
@smallexample
'One string isn''t two',"one more"
@end smallexample
@noindent
can be read by
@smallexample
read.table("testfile", sep=",")
@end smallexample
@noindent
This does not work with the default separator.

@item @strong{Missing values}  
@cindex missing values

By default the file is assumed to contain
the character string @code{NA} to represent missing values, but this can
be changed by the argument @code{na.strings}, which is a vector of one
or more character representations of missing values.

Empty fields in numeric columns are also regarded as missing values.

@item @strong{Unfilled lines}

It is quite common for a file exported from a spreadsheet to have all
trailing empty fields (and their separators) omitted. To read such files
set @code{fill = TRUE}.

@item @strong{White space in character fields}

If a separator is specified, leading and trailing white space in
character fields is regarded as part of the field.  To strip the space,
use argument @code{strip.white = TRUE}.

@end enumerate

@findex read.csv
@findex read.csv2
@findex read.delim
@findex read.delim2
@cindex CSV files
Convenience functions @code{read.csv} and @code{read.delim} provide
arguments to @code{read.table} appropriate for CSV and tab-delimited
files exported from spreadsheets in English-speaking locales.  The
variations @code{read.csv2} and @code{read.delim2} are appropriate
for use in countries where the comma is used for the decimal point.

If the options to @code{read.table} are specified incorrectly, the error
message will usually be of the form
@smallexample
row.lens=
 [1] 4 4 5 5 5 4 6 4 4 4 5 4 4 5 5
Error in read.table("file.dat", header = TRUE) : 
        all rows must have the same length.
@end smallexample
@findex count.fields
@noindent
This may give enough information to find the problem, but the auxiliary
function @code{count.fields} can be useful to investigate further.

@node Fixed-width-format files, Using scan directly, Variations on read.table, Spreadsheet-like Data
@section Fixed-width-format files
@cindex Fixed-width-format files

Sometimes data files have no field delimiters but have fields in
pre-specified columns.  This was very common in the days of punched cards,
and is still sometimes used to save file space.

@findex read.fwf
Function @code{read.fwf} provides a simple way to read such files,
specifying a vector of field widths. The function reads the file into
memory as whole lines, splits the resulting character strings, writes
out a temporary tab-separated file and then calls @code{read.table}.
This is adequate for small files, but for anything more complicated we
recommend using the facilities of a language like @code{perl} to
pre-process the file.
@cindex Perl

@node Using scan directly, Re-shaping Data, Fixed-width-format files, Spreadsheet-like Data
@section  Using @code{scan} directly
@findex scan

Both @code{read.table} and @code{read.fwf} use @code{scan} to read the
file, and then process the results of @code{scan}.  They are very
convenient, but sometimes it is better to use @code{scan} directly.

One reason can be to reduce memory usage.  Function @code{read.table}
reads the whole data file into memory and processes it into a data
frame, thereby creating another copy of the data.  If the
post-processing is not required (for example if most of the variables
are to be discarded) it may be feasible to use @code{scan} but not to
use @code{read.table}.

Function @code{scan} has many arguments, most of which we have already
covered under @code{read.table}.  The most crucial argument is
@code{what}, which specifies a list of modes of variables to be read
from the file.  If the list is named, the names are used for the
components of the returned list.  Modes can be numeric, character or
complex, and are usually specified by an example, e.g. @code{0},
@code{""} or @code{0i}.  For example
@smallexample
cat("2 3 5 7", "11 13 17 19", file="ex.dat", sep="\n")
scan(file="ex.dat", what=list(x=0, y="", z=0), flush=TRUE)
@end smallexample
@noindent
returns a list with three components and discards the fourth column in
the file.

@node Re-shaping Data,  , Using scan directly, Spreadsheet-like Data
@section Re-shaping Data
@cindex Re-shaping Data

Sometimes spreadsheet data is in a compact format that gives the covariates
for each subject followed by all the observations on that subject.
@R{}'s modelling functions need observations in a single column.
Consider the following sample of data from repeated MRI measurements
@example
 Status   Age    V1     V2     V3    V4
      P 23646 45190  50333  55166 56271
     CC 26174 35535  38227  37911 41184
     CC 27723 25691  25712  26144 26398
     CC 27193 30949  29693  29754 30772
     CC 24370 50542  51966  54341 54273
     CC 28359 58591  58803  59435 61292
     CC 25136 45801  45389  47197 47126
@end example
@noindent
There are two covariates and up to four measurements on each subject.

@findex stack
We can use @code{stack} to help manipulate these data to give a single
response.
@smallexample
zz <- read.csv("mr.csv", strip.white=T)
zzz <- cbind(zz[gl(7, 1, 28), 1:2], stack(zz[, 3:6]))
@end smallexample
@noindent
with result
@example
      Status   Age values ind
X1         P 23646  45190  V1
X2        CC 26174  35535  V1
X3        CC 27723  25691  V1
X4        CC 27193  30949  V1
X5        CC 24370  50542  V1
X6        CC 28359  58591  V1
X7        CC 25136  45801  V1
X11        P 23646  50333  V2
...
@end example

@findex unstack.
Function @code{unstack} goes in the opposite direction, and may be
useful for exporting data.

@node Importing from Other Statistical Systems, Relational Databases, Spreadsheet-like Data, Top
@chapter Importing from Other Statistical Systems
@cindex Importing from other statistical systems

In this chapter we consider the problem of reading a binary data file
written by another statistical system.  This is often best avoided, but
may be unavoidable if the originating system is not available.

@menu
* Stata::                       
* Minitab::                     
* SAS::                         
* S-PLUS::                      
* SPSS::                        
@end menu

@node Stata, Minitab, Importing from Other Statistical Systems, Importing from Other Statistical Systems
@section Stata
@cindex Stata
@findex read.dta
@findex write.dta

Import and export facilities for Stata @file{.dta} files and provided by
package @pkg{stataread} on CRAN. This is a binary file format, and files
from versions 5.0 and 6.0 of Stata can be read and (despite the package
name) written by functions @code{read.dta} and @code{write.dta}.

@node Minitab, SAS, Stata, Importing from Other Statistical Systems
@section Minitab
@findex read.mtp

Package @pkg{foreign} in the Devel section on CRAN provides a function
@code{read.mtp} to read a `Minitab Portable Worksheet'.  This returns
the components of the worksheet as an @R{} list.

@node SAS, S-PLUS, Minitab, Importing from Other Statistical Systems
@section SAS
@cindex SAS
@findex read.xport

Package @pkg{foreign} in the Devel section on CRAN provides a function
@code{read.xport} to read a file in SAS Transport (XPORT) format
and returns a list of data frames.

@node S-PLUS, SPSS, SAS, Importing from Other Statistical Systems
@section S-PLUS
@cindex S-PLUS
@findex readSfile

Package @pkg{Rstreams} on CRAN contains a function @code{readSfile}
which can read binary objects produced by S-PLUS 3.x, 4.x or 2000 on
Unix or Windows (and can read them on a different OS). This is able
to read many but not all @Sl{} objects: in particular it can read
vectors, matrices and data frames.

@node SPSS,  , S-PLUS, Importing from Other Statistical Systems
@section SPSS
@cindex SPSS
@cindex PSPP

There are currently no facilities to import SPSS data files, but it may
be possible to use the PSPP package (@url{http://pspp.stat.wisc.edu}) to
convert these files to a text format.


@node Relational Databases, Binary Files, Importing from Other Statistical Systems, Top
@chapter Relational Databases

@cindex Relational databases
@cindex DBMS

@menu
* SQL queries::                 
* RMySQL::                      
* RPgSQL::                      
* RmSQL::                       
* RODBC::                       
@end menu

There are a variety of packages available on CRAN to help @R{}
communicate with DBMSs.  They provide different levels of abstraction.
Some provide means to copy whole data frames to and from databases.  All
have functions to select data with the database via SQL queries, and
(except @pkg{RmSQL}) to retrieve the result as a whole as a data frame
or in pieces (usually as groups of rows, but @pkg{RPgSQL} can retrieve
columns).  All except @pkg{RODBC} are (currently) tied to one DBMS.

@node SQL queries, RMySQL, Relational Databases, Relational Databases
@section SQL Queries
@cindex SQL queries

All of the packages described later in this chapter provide clients to
client/server relational databases.  The database can reside on the same
machine or (more often) remotely.  There is an ISO standard (in fact
several: SQL-92 is ISO/IEC 9075, also known as ANSI X3.135-1992) for an
interface language called SQL (Structured Query Language, sometimes
pronounced `sequel': see Bowman @emph{et al.@:} 1996) which these DBMSs
support to varying degrees.  Conventionally SQL is written in upper
case, but most users will find it more convenient to use lower case in
the @R{} interface functions.

A relational DBMS stores data as a database of @emph{tables} (or
@emph{relations}) which are rather similar to @R{} data frames, in that
they are made up of @emph{columns} or @emph{fields} of one type
(numeric, character, date, currency, @dots{}) and @emph{rows} or
@code{records} containing the observations for one entity.

SQL `queries' are quite general operations on a relational database.
The classical query is a SELECT statement of the type
@smallexample
SELECT State, Murder FROM USArrests WHERE rape > 30 ORDER BY Murder

SELECT t.sch, c.meanses, t.sex, t.achieve 
  FROM student as t, school as c WHERE t.sch = c.id

SELECT sex, COUNT(*) FROM student GROUP BY sex

SELECT sch, AVG(sestat) FROM student GROUP BY sch LIMIT 10;
@end smallexample
@noindent
The first of these selects two columns from the @R{} data frame
@code{USArrests} that has been copied across to a database table,
subsets on a third column and asks the results be sorted.  The second
performs a database @emph{join} on two tables @code{student} and
@code{school} and returns four columns.  The third and fourth queries do
some cross-tabulation and return counts or averages. (The five
aggregation functions are COUNT(*) and SUM, MAX, MIN and AVG, each
applied to a single column.)

There are queries to create a table (CREATE TABLE, but usually one
copies a data frame to the database in these interfaces), INSERT or
DELETE or UPDATE data.  A table is destroyed by a DROP TABLE `query'.

SELECT queries use FROM to select the table, WHERE to specify a condition
for inclusion (or more than one condition separated by AND or OR), and
ORDER BY to sort the result.  Unlike data frames, RDBMS tables are best
thought of as unordered, and without an ORDER BY statement the ordering
is indeterminate.  You can sort (in lexicographical order) on more than
one column by separating them by commas. Placing DESC after an ORDER BY
puts the sort in descending order.

SELECT DISTINCT queries will only return one copy of each distinct
row in the selected table.

The GROUP BY clause selects subgroups of the rows according to the
criterion. If more than one column is specified (separated by commas)
then multi-way cross-classifications can be summarized by one of the
five aggregation functions.  A HAVING clause allows the summary to
include or exclude groups depending on the aggregated value.

@node RMySQL, RPgSQL, SQL queries, Relational Databases
@section Package RMySQL
@cindex MySQL database system

Package @pkg{RMySQL} in the Devel section on CRAN provides an interface
to the MySQL database system (see @url{http://www.mysql.com} and Dubois,
2000.).  This is part of a project to provide a common API for access
from @R{} to relational DBMSs using SQL.

MySQL exists on Unix/Linux and Windows.  (Its current status appears to
be that the source is freely available and beta versions are free but
release versions are commercial on Windows.)  MySQL is a `light and
lean' database.


Package @pkg{RMySQL}
appears only to run on Unix/Linux.

@findex MySQL
@findex dbConnect
@findex close
A call to the function @code{MySQL} returns a database connection
manager, and then a call to @code{dbConnect} opens a database connection
which can subsequently be closed by a call to the generic function
@code{close}.

@findex dbExec
@findex dbExecStatement
SQL queries can be sent by either @code{dbExec} or
@code{dbExecStatement}.  @code{dbExec} sends the query and retrieves the
results as a list.  @code{dbExecStatement} sends the query and returns
an object of class @code{"MySQLResultSet"} which can be used to retrieve
the results, and subsequently used to @code{close} the result.

@findex fetch
Function @code{fetch} is used to retrieve some or all of the rows in the
query result, as a list. The function @code{hasCompleted} indicates if
all the rows have been fetched, and @code{getRowCount} returns the
number of rows in the result.


@node RPgSQL, RmSQL, RMySQL, Relational Databases
@section Package RPgSQL
@cindex PostgreSQL database system

Package @pkg{RPgSQL} at @url{http://rpgsql.sourceforge.net/} and on CRAN
provides an interface to the PostgreSQL database system
(@url{http://www.postgresql.org}).

PostgreSQL is described by its developers as `the most advanced open
source database server' (Momjian, 2000), but has commercial support
available. It would appear to be buildable for most Unix-alike OSes and
Windows (under Cygwin or U/Win).  PostgreSQL has most of the features of
the commercial RDBMSs.


@findex db.connect
@findex db.read.table
@findex db.write.table
To make use of @pkg{RPgSQL}, first open a connection to a database
using @code{db.connect}. (Currently only one connection can be open at a
time.)  Once a connection is open an @R{} data frame can be copied to a
PostgreSQL table by @code{db.write.table}, whereas @code{db.read.table}
copies a PostgreSQL table to an @R{} data frame.

@findex bind.db.proxy
@cindex proxy data frame
@pkg{RPgSQL} has the interesting concept of a @emph{proxy data frame}.
A data frame proxy is an @R{} object that inherits from the
@code{"data.frame"} class, but contains no data.  All accesses to the
proxy data frame generate the appropriate SQL query and retrieve the
resulting data from the database.  A prxoy data frame is set up by a
call to @code{bind.db.proxy}.

@findex db.execute
@findex db.result.columns
@findex db.result.rows
@findex db.read.column
@findex db.fetch.result
@findex db.result.get.value
A finer level of control is available via sending SQL queries to the
PostgreSQL via @code{db.execute}. Once this is done,
@code{db.fetch.result} can be used to fetch the whole result as a data
frame.  Functions such as @code{db.result.columns} and
@code{db.result.rows} will report the number of columns and rows in the
resulting table, and @code{db.read.column} will fetch a single column
(as a vector).  An individual cell in the table can be read by
@code{db.result.get.value}.

@pkg{RPgSQL} provides a means to extend its mapping of @R{} classes
within a data frame to PostgreSQL types.

We can explore these functions in a simple example.  The database
@file{testdb} has already been set up, and as this was running on a
standalone machine, no authentication was required to connect.
@example
> library(RPgSQL)
> db.connect(dbname="testdb")
Connected to database "testdb" on ""
> data(USArrests)
> db.write.table(USArrests)
> rm(USArrests)
# db.ls lists tables in the database.
> db.ls()
[1] "USArrests"
> db.read.table("USArrests")
   ...
## set up a proxy data frame. Remember, USArrests has been removed
> bind.db.proxy("USArrests")
## USArrests is now a proxy, so all accesses are to the database
> USArrests[, "Rape"]
   Rape
1  21.2
2  44.5
   ...
> db.execute("SELECT State,Murder FROM USArrests WHERE Rape > 30
             ORDER  BY Murder", clear=FALSE)
> db.fetch.result()
       state murder
1 Colorado      7.9
2 Arizona       8.1
3 California    9.0
4 Alaska       10.0
5 New Mexico   11.4
6 Michigan     12.1
7 Nevada       12.2
8 Florida      15.4
## note the columns names got mapped to lower case

> db.rm("USArrests")  # use ask=F to avoid the query
Destroy table USArrests? y
> db.ls()
character(0)
> db.disconnect()
@end example

@node RmSQL, RODBC, RPgSQL, Relational Databases
@section Package RmSQL
@cindex mSQL database system

Package @pkg{RmSQL} on CRAN provides an interface to the mSQL database
system (@url{http://www.Hughes.com.au}, Yarger @emph{et al.@:},
1999). The package documentation describes mSQL as
@quotation
Note that mSQL is NOT GPL licenced but free of charge for universities
and noncommercial organisations.
@end quotation
@noindent
@pkg{RmSQL} provides the most basic interface of those in this chapter.

@findex msqlConnect
@findex msqlSelect
@findex msqlClose
@findex msqlQuery
@findex msqlStoreResult
@findex msqlFreeResult
A database connection is opened by first selecting a host with
@code{msqlConnect} and then a database by @code{msqlSelect}. The
connection is closed by a call to @code{msqlClose}.  Then an SQL query is
sent by a call to @code{msqlQuery}, and the results stored by a call to
@code{msqlStoreResult}.  When a query is finished with, the result can
be freed by @code{msqlFreeResult}.

@findex msqlFetchRow
@findex msqlDataSeek
@findex msqlNumRows
Once the result of a query has been stored, the values can be retrieved
row by row using @code{msqlFetchRow}.  This fetches the rows in order
unless the position is reset by a call to @code{msqlDataSeek}. A call to
@code{msqlNumRows} gives the total number of rows in the result.


@node RODBC,  , RmSQL, Relational Databases
@section Package RODBC
@cindex ODBC database connectivity

Package @pkg{RODBC} on CRAN provides an interface to database sources
supporting the ODBC interface.  Many databases support ODBC, including
most of those on Windows (such as MicroSoft Access), and MySQL, Oracle
and PostgreSQL on Unix/Linux.  @pkg{RODBC} runs on both Linux and
Windows.  You need an ODBC Driver Manager such as unixODBC
(@url{http://www.unixODBC.org}) on Unix.

Two groups of interface functions are provided. The @code{odbc*} group
provide a low-level interface to the basic ODBC functions: see the help
page @code{?RODBC} for details. The @code{sql*} group provide an
interface between @R{} data frames and SQL tables.

@findex odbcConnect
@findex odbcClose
Up to 16 simultaneous connections are possible.  A connection is opened
by a call to @code{odbcConnect} and returns a handle used for subsequent
access to the database.  A connection is closed by @code{odbcClose}.

@findex sqlFetch
@findex sqlSave
Function @code{sqlSave} copies an @R{} data frame to a table in the
database, and @code{sqlFetch} copies a table in the database to an
@R{} data frame.

@findex sqlQuery
@findex sqlCopy
@findex odbcQuery
@findex sqlGetResults
@findex odbcGetResults
An SQL query can be sent to the database by a call to @code{sqlSquery}.
This returns the result in an @R{} data frame.  @code{sqlCopy} sends a
query to the database and saves the result as a table in the database.
A finer level of control is attained by first calling @code{odbcQuery}
and then @code{sqlGetResults} to fetch the results.  The latter can be
used within a loop to retrieve a limited number of rows at a time.
@code{sqlGetResults} returns a data frame, but the raw results as a
matrix can be obtained from @code{odbcGetResults}.

Here is an example using PostgreSQL, for which the ODBC driver maps
column names to lower case.  We use the database @code{testdb} we
created earlier, and have the DSN (data source name set up, in
@file{~/.odbc.ini} under @code{unixODBC}.

@example
library(RODBC)
## tell it postgresql ODBC is in use, so names are mapped to l/case
channel <- odbcConnect("test", "", "", "postgresql")
## load the data frame into the database
data(USArrests)
sqlSave(channel, USArrests, rownames="state")
rm(USArrests)
## list it
sqlFetch(channel,"USArrests")
## an SQL query, originally on one line
sqlQuery(channel, "select state, murder from USArrests 
         where rape > 30 order by murder")
# remove the table
sqlDrop(channel, USArrests)
## close the connection
odbcClose(channel)
@end example

@node Binary Files, Network Connections, Relational Databases, Top
@chapter Binary Files
@cindex Binary files

@menu
* Package Rstreams::            
* Binary Data Formats::         
@end menu

@node Package Rstreams, Binary Data Formats, Binary Files, Binary Files
@section Package Rstreams

Package @pkg{Rstreams} on CRAN provides a low-level interface to read
from and write to binary files.  It has been used to read in data from
MRI experiments and Windows sound files, for example.

@findex openstream
@findex closestream
@pkg{Rstreams}' view of the file is as a stream of bytes.  A file can be
opened by the function @code{openstream} for either reading or writing.
The return value is a number (in fact the file descriptor) that is used
to reference the open file until it is closed by @code{closestream}.

@findex readint
@findex readfloat
@findex readcomplex
@findex readchar
Once a stream is open for reading, bytes can be transferred from it
to an @R{} object by one of the functions 
@example
readint(stream, n, size = 4, signed = TRUE, swapbytes = FALSE)
readfloat(stream, n, size = 8, swapbytes = FALSE)
readcomplex(stream, n, size = 8, swapbytes = FALSE)
readchar(stream, n = 1, len = NA, bufsize = 256)
@end example
@noindent
These return an @R{} object of an appropriate mode and storage mode.
(Integers too large to be represented in storage mode @code{"integer"}
will be read into a vector of storage mode @code{"double"}.)
Here @code{n} is the number of items to be read, but fewer will be read
if there is insufficient data on the file.

The size of the data components on file need not be the same as that in
the machine running @R{}, and data written on a little-endian machine can
be read on a big-endian machine or @emph{vice versa} by setting
@code{swapbytes = TRUE}.

Character data can be read either as fixed-length blocks of bytes (by
specifying @code{len}) or as ASCII-zero-delimited strings.

@findex writeint
@findex writefloat
@findex writecomplex
@findex writechar
A file open for writing can be written to by any of
@example
writeint(stream, data, size = 4, swapbytes = FALSE)
writefloat(stream, data, size = 8, swapbytes = FALSE)
writecomplex(stream, data, size = 8, swapbytes = FALSE)
writechar(stream, data, asciiz = FALSE)
@end example
@noindent
where @code{data} is an @R{} vector of an appropriate mode.  There is no
separator between character strings on the file unless @code{asciiz =
TRUE} is specified.

@findex copystream
Function @code{copystream} can copy a specified number of bytes from one
open stream to another.

@findex truncate
Function @code{truncate} truncates a stream at its current position, so
all data after that point is lost.


@node Binary Data Formats,  , Package Rstreams, Binary Files
@section Binary Data Formats
@findex hdf5
@findex netCDF
@cindex Hierarchical Data Format
@cindex network Common Data Form

Packages @pkg{hdf5} and @pkg{netCDF} in the Devel area on CRAN provide
experimental interfaces to NASA's HDF5 (Hierarchical Data Format,
see @url{http://hdf.ncsa.uiuc.edu/HDF5/}) and to UCAR's netCDF data files
(network Common Data Form, see
@url{http://www.unidata.ucar.edu/packages/netcdf/}), respectively.

Both of these are systems to store scientific data in array-oriented
way, including descriptions, labels, formats, units, @dots{}. HDF5 also
allows @emph{groups} of arrays, and the @R{} interface writes maps lists
to HDF5 groups, and can write numeric and character vectors and
matrices.

The @R{} interface can only read netCDF, not write it.


@node Network Connections, References, Binary Files, Top
@chapter Network Connections

@menu
* Reading from Sockets::        
* Using download.file::         
* DCOM Interface::              
* CORBA Interface::             
@end menu

Some limited facilities are available to exchange data at a lower level
across network connections.

@node Reading from Sockets, Using download.file, Network Connections, Network Connections
@section Reading from Sockets

Base @R{} comes with some facilities to communicate @emph{via} BSD
sockets on systems that support them (including the common Linux, Unix
and Windows ports of @R{}).   One potential problem with using sockets
is that these facilities are often blocked for security reasons or to
force the use of Web caches, so these functions may be more useful on an
intranet than externally.

@findex make.socket
@findex read.socket
@findex write.socket
@findex close.socket
@findex httpclient
The low-level interface is given by functions @code{make.socket},
@code{read.socket}, @code{write.socket} and @code{close.socket}.  The
function @code{httpclient} builds on these to read (directly) from an
HTTP server.

@node Using download.file, DCOM Interface, Reading from Sockets, Network Connections
@section Using @code{download.file}

@findex read.table.url
@findex scan.url
@cindex wget
@cindex lynx
There are  functions @code{read.table.url} and @code{scan.url} that
appear to work like @code{read.table} and @code{scan} but access a Web
resource at a specified URL.  Appearances are deceptive, however, as
these functions (and @code{url.show} and @code{source.url}) first
download the Web resource to a local file and then apply the standard
functions.  Various methods can be used to download the file, including
the programs @code{wget} and @code{lynx} and the direct use of BSD sockets.


@node DCOM Interface, CORBA Interface, Using download.file, Network Connections
@section DCOM Interface
@cindex DCOM

DCOM is a Windows protocol for communicating between different programs,
possibly on different machines.  Thomas Baier's @code{StatConnector}
program available from CRAN under Software->Other->Non-standard
provides an interface to the proxy DLL which ships with the Windows
version of @R{} and makes an DCOM server.  This can be used to pass
simple objects (vectors and matrices) to and from @R{} and to submit
commands to @R{}.  

The program comes with a Visual Basic demonstration, and there is an
Excel plug-in by Erich Neuwirth available in the same area on CRAN.
This interface is in the other direction to most of those considered
here in that it is another application (Excel, or written in Visual
Basic) that is the client and @R{} is the server.

@node CORBA Interface,  , DCOM Interface, Network Connections
@section CORBA Interface
@cindex CORBA

An interface to @R{} providing communication via CORBA objects is
available from the Omegahat Project (@url{http://www.omeghat.org}).

@node References, Function and variable index, Network Connections, Top
@appendix References

@noindent
R.@: A.@: Becker, J.@: M.@: Chambers and A.@: R.@: Wilks (1988) @emph{The New
S Language. A Programming Environment for Data Analysis and Graphics.}
Wadsworth & Brooks/Cole.

@noindent
J.@: Bowman, S.@: Emberson and M.@: Darnovsky. (1996) @emph{The
Practical SQL Handbook. Using Structured Query Language.}
Addison-Wesley.

@noindent
P.@: Dubois (2000) @emph{MySQL.} New Riders.

@noindent
B.@: Momjian (2000) @emph{PostgreSQL: Introduction and Concepts.}
Draft book from @url{http://www.postgresql.org/docs/awbook.html}.

@noindent
T.@: M.@: Therneau and P.@: M.@: Grambsch (2000) @emph{Modeling Survival
Data. Extending the Cox Model.} Springer-Verlag.

@noindent
E.@: J.@: Yarger, G.@: Reese and T.@ King (1999) @emph{MySQL & mSQL}.
O'Reilly.

@node Function and variable index, Concept index, References, Top
@unnumbered Function and variable index

@printindex vr

@node Concept index,  , Function and variable index, Top
@unnumbered Concept index

@printindex cp


@bye

@c Local Variables: ***
@c mode: TeXinfo ***
@c End: ***
