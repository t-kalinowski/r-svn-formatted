family <- function(object, ...) UseMethod("family")

print.family <- function(x, ...)
{
	cat("\nFamily:", x$family, "\n")
	cat("Link function:", x$link, "\n\n")
}
power <- function(lambda = 1)
{
	if(lambda <= 0)
		return("log")
	return(lambda)
}

## Written by Simon Davies Dec 1995
## Modified by Thomas Lumley 26 Apr 97
## added valideta(eta) function returning TRUE if all of eta
## is in the domain of linkinv
make.link <- function (link)
{
 ## This function is used with  glm().
 ## Given a link, it returns a link function, an inverse link
 ## function and the derivative dmu/deta.
 switch (link,
	 "logit" = {
		linkfun <- function(mu) log(mu/(1 - mu))
		linkinv <- function(eta) exp(eta)/(1 + exp(eta))
		mu.eta <- function(eta) exp(eta)/(1 + exp(eta))^2
		valideta <- function(eta) TRUE
	      },
	 "probit" = {
		linkfun <- function(mu) qnorm(mu)
		linkinv <- pnorm
		mu.eta <- function(eta) 0.3989422 * exp(-0.5 * eta^2)
		valideta <- function(eta) TRUE
	      },
	 "cloglog" = {
		linkfun <- function(mu) log(-log(1 - mu))
		linkinv <- function(eta) 1 - exp(-exp(eta))
		mu.eta <- function(eta) exp(eta) * exp(-exp(eta))
		valideta <- function(eta) TRUE
	      },
	 "identity" = {
		linkfun <- function(mu) mu
		linkinv <- function(eta) eta
		mu.eta <- function(eta) rep(1, length(eta))
		valideta <- function(eta) TRUE
	      },
	 "log" = {
		linkfun <- function(mu) log(mu)
		linkinv <- function(eta) exp(eta)
		mu.eta <- function(eta) exp(eta)
		valideta <- function(eta) TRUE
	      },
	 "sqrt" = {
		linkfun <- function(mu) mu^0.5
		linkinv <- function(eta) eta^2
		mu.eta <- function(eta) 2 * eta
		valideta <- function(eta) all(eta>0)
	      },
	 "1/mu^2" = {
		linkfun <- function(mu) 1/mu^2
		linkinv <- function(eta) 1/eta^0.5
		mu.eta <- function(eta) -1/(2 * eta^1.5)
		valideta <- function(eta) all(eta>0)
	      },
	 "inverse" = {
		linkfun <- function(mu) 1/mu
		linkinv <- function(eta) 1/eta
		mu.eta <- function(eta) -1/(eta^2)
		valideta <- function(eta) all(eta!=0)
	      },
	 ## else :
	 {
	   if (!is.na(as.numeric(link))) {
		lambda <- as.numeric(link)
		linkfun <- function(mu) mu^lambda
		linkinv <- function(eta) eta^(1/lambda)
		mu.eta <- function(eta) (1/lambda) * eta^(1/lambda - 1)
		valideta <- function(eta) all(eta>0)
	   } else
		stop(paste(link, "link not recognised"))
	 }
	 )# end switch(.)
 list(linkfun = linkfun, linkinv = linkinv,
      mu.eta = mu.eta, valideta = valideta)
}

poisson <- function (link = "log")
{
	linktemp <- substitute(link)
	## this is a function used in  glm().
	## It holds everything personal to the family,
	## converts link into character string
	if (!is.character(linktemp)) {
		linktemp <- deparse(linktemp)
		if (linktemp == "link")
			linktemp <- eval(link)
	}
	if (any(linktemp == c("log", "identity", "sqrt")))
		stats <- make.link(linktemp)
	else stop(paste(linktemp, "link not available for poisson",
			"family; available links are",
			'"identity", "log" and "sqrt"'))
	variance <- function(mu) mu
	validmu <- function(mu) all(mu>0)
	dev.resids <- function(y, mu, wt)
		2 * wt * (y * log(ifelse(y == 0, 1, y/mu)) - (y - mu))
	aic <- function(y, n, mu, wt, dev)
		2*sum((mu-y*log(mu)+lgamma(y+1))*wt)
	initialize <- expression({
		if (any(y < 0))
			stop(paste("Negative values not allowed for",
				"the Poisson family"))
		n <- rep(1, nobs)
		mustart <- y + 0.1
	})
	structure(list(family = "poisson",
			link = linktemp,
			linkfun = stats$linkfun,
			linkinv = stats$linkinv,
			variance = variance,
			dev.resids = dev.resids,
			aic = aic,
			mu.eta = stats$mu.eta,
			initialize = initialize,
			validmu = validmu,
			valideta = stats$valideta),
		  class = "family")
}

gaussian <- function (link = "identity")
{
	linktemp <- substitute(link)
	## This is a function used in  glm();
	## it holds everything personal to the family
	## converts link into character string
	if (!is.character(linktemp)) {
		linktemp <- deparse(linktemp)
		if (linktemp == "link")
			linktemp <- eval(link)
	}
	if (any(linktemp == c("inverse", "log", "identity")))
		stats <- make.link(linktemp)
	else stop(paste(linktemp, "link not available for gaussian",
		"family, available links are \"inverse\", ",
		"\"log\" and \"identity\""))
 structure(list(family = "gaussian",
                  link = linktemp,
		  linkfun = stats$linkfun,
		  linkinv = stats$linkinv,
                  variance = function(mu) rep(1, length(mu)),
                  dev.resids = function(y, mu, wt) wt * ((y - mu)^2),
                  aic =	function(y, n, mu, wt, dev)
	                        sum(wt)*(log(dev/sum(wt)*2*pi)+1)+2,
		  mu.eta = stats$mu.eta,
                  initialize = expression({
                  		n <- rep(1, nobs)
				mustart <- y }),
                  validmu = function(mu) TRUE
                  ),
           class = "family")
}

binomial <- function (link = "logit")
{
	linktemp <- substitute(link)
	## this is a function used in  glm();
	## it holds everything personal to the family
	## converts link into character string
	if (!is.character(linktemp)) {
		linktemp <- deparse(linktemp)
		if (linktemp == "link")
			linktemp <- eval(link)
	}
	if (any(linktemp == c("logit", "probit", "cloglog", "log")))
		stats <- make.link(linktemp)
	else stop(paste(linktemp, "link not available for binomial",
		"family, available links are \"logit\", ",
		"\"probit\" and \"cloglog\""))
	variance <- function(mu) mu * (1 - mu)
	validmu <- function(mu) all(mu>0) && all(mu<1)
	dev.resids <- function(y, mu, wt)
		2 * wt * (y * log(ifelse(y == 0, 1, y/mu)) +
		(1 - y) * log(ifelse(y == 1, 1, (1 - y)/(1 - mu))))
	aic <- function(y, n, mu, wt, dev)
		-2*sum((lchoose(n,n*y)+n*(y*log(mu)+(1-y)*log(1-mu)))*wt/n)
	initialize <- expression({
		if (NCOL(y) == 1) {
                  # allow factors as responses
                  # added BDR 29/5/98
                  if (is.factor(y)) y <- y != levels(y)[1]
                  n <- rep(1, nobs)
			if (any(y < 0 | y > 1))
				stop("y values must be 0 <= y <= 1")
		}
		else if (NCOL(y) == 2) {
			n <- y[, 1] + y[, 2]
			y <- ifelse(n == 0, 0, y[, 1]/n)
			weights <- weights * n
		}
		else stop(paste("For the binomial family, y must be",
			"a vector of 0 and 1\'s or a 2 column",
			"matrix where col 1 is no. successes",
			"and col 2 is no. failures"))
		mustart <- (n * y + 0.5)/(n + 1)
	})
	structure(list(family = "binomial",
			link = linktemp,
			linkfun = stats$linkfun,
			linkinv = stats$linkinv,
			variance = variance,
			dev.resids = dev.resids,
			aic = aic,
			mu.eta = stats$mu.eta,
			initialize = initialize,
			validmu = validmu,
			valideta = stats$valideta),
		  class = "family")
}

Gamma <- function (link = "inverse")
{
	linktemp <- substitute(link)
	## This is a function used in  glm();
	## it holds everything personal to the family
	## converts link into character string
	if (!is.character(linktemp)) {
		linktemp <- deparse(linktemp)
		if (linktemp == "link")
			linktemp <- eval(link)
	}
	if (any(linktemp == c("inverse", "log", "identity")))
		stats <- make.link(linktemp)
	else stop(paste(linktemp, "link not available for gamma",
		"family, available links are \"inverse\", ",
		"\"log\" and \"identity\""))
	variance <- function(mu) mu^2
	validmu <- function(mu) all(mu>0)
	dev.resids <- function(y, mu, wt)
		-2 * wt * (log(ifelse(y == 0, 1, y/mu)) - (y - mu)/mu)
	aic <- function(y, n, mu, wt, dev){
		n <- sum(wt)
		disp <- dev/n
		2*((sum(wt*(y/mu+log(mu)-log(y)))+n*log(disp))/disp+
			n*lgamma(1/disp)+sum(log(y)*wt)+1)}
	initialize <- expression({
		if (any(y <= 0))
			stop(paste("Non-positive values not",
				"allowed for the gamma family"))
		n <- rep(1, nobs)
		mustart <- y
	})
	structure(list(family = "Gamma",
			link = linktemp,
			linkfun = stats$linkfun,
			linkinv = stats$linkinv,
			variance = variance,
			dev.resids = dev.resids,
			aic = aic,
			mu.eta = stats$mu.eta,
			initialize = initialize,
			validmu = validmu,
			valideta = stats$valideta),
		  class = "family")
}

inverse.gaussian <- function(link = "1/mu^2")
{
	linktemp <- substitute(link)
	## This is a function used in  glm();
	## it holds everything personal to the family
	## converts link into character string
	if (!is.character(linktemp)) {
		linktemp <- deparse(linktemp)
		if (linktemp == "link")
			linktemp <- eval(link)
	}
	if (any(linktemp == c("inverse", "log", "identity", "1/mu^2")))
		stats <- make.link(linktemp)
	else stop(paste(linktemp, "link not available for inverse gauss",
		"family, available links are \"inverse\", ",
		"\"1/mu^2\" \"log\" and \"identity\""))
#	stats <- make.link("1/mu^2")
	variance <- function(mu) mu^3
	dev.resids <- function(y, mu, wt)  wt*((y - mu)^2)/(y*mu^2)
	aic <- function(y, n, mu, wt, dev)
		sum(wt)*(log(dev/sum(wt)*2*pi)+1)+3*sum(log(y)*wt)+2
	initialize <- expression({
			if(any(y <= 0))
				stop(paste("Positive values only allowed for",
					"the inverse.gaussian family"))
			n <- rep(1, nobs)
			mustart <- y
			})
	validmu <- function(mu) TRUE

	structure(list(family = "inverse.gaussian",
			link = "1/mu^2",
			linkfun = stats$linkfun,
			linkinv = stats$linkinv,
			variance = variance,
			dev.resids = dev.resids,
			aic = aic,
			mu.eta = stats$mu.eta,
			initialize = initialize,
			validmu = validmu,
			valideta = stats$valideta),
	class = "family")
}

quasi <- function (link = "identity", variance = "constant")
{
	linktemp <- substitute(link)
	#this is a function used in  glm()
	#it holds everything personal to the family
	#converts link into character string
	if (is.expression(linktemp))
		linktemp <- eval(linktemp)
	if (!is.character(linktemp)) {
		linktemp <- deparse(linktemp)
		if (linktemp == "link")
			linktemp <- eval(link)
	}
	stats <- make.link(linktemp)
	#converts variance into character string
	variancetemp <- substitute(variance)
	if (!is.character(variancetemp)) {
		variancetemp <- deparse(variancetemp)
		if (linktemp == "variance")
			variancetemp <- eval(variance)
	}
	switch(variancetemp,
	       "constant" = {
			variance <- function(mu) rep(1, length(mu))
			dev.resids <- function(y, mu, wt) wt * ((y - mu)^2)
			validmu <-function(mu) TRUE
		      },
	       "mu(1-mu)" = {
			variance <- function(mu) mu * (1 - mu)
			validmu <-function(mu) all(mu>0) && all(mu<1)
			dev.resids <- function(y, mu, wt)
				2 * wt * (y * log(ifelse(y == 0, 1, y/mu)) +
			 (1 - y) * log(ifelse(y == 1, 1, (1 - y)/(1 - mu))))
		      },
	       "mu" = {
			variance <- function(mu) mu
			validmu<-function(mu) all(mu>0)
			dev.resids <- function(y, mu, wt)
			  2 * wt * (y * log(ifelse(y == 0, 1, y/mu)) - (y - mu))
		      },
	       "mu^2" = {
			variance <- function(mu) mu^2
			validmu<-function(mu) all(mu!=0)
			dev.resids <- function(y, mu, wt)
				pmax(-2 * wt * (log(y/mu) - (y - mu)/mu), 0)
		      },
	       "mu^3" = {
			variance <- function(mu) mu^3
			validmu <-function(mu) all(mu>0)
			dev.resids <- function(y, mu, wt)
				wt * ((y - mu)^2)/(y * mu^2)
		      },
	       stop(paste(variancetemp, "not recognised, possible variances",
			'are "mu(1-mu)", "mu", "mu^2", "mu^3" and "constant"'))
	       )# end switch(.)

	initialize <- expression({ n <- rep(1, nobs); mustart <- y })
            aic <- function(y, n, mu, wt, dev) NA
	structure(list(family = "quasi",
                       link = linktemp,
                       linkfun = stats$linkfun,
                       linkinv = stats$linkinv,
                       variance = variance,
                       dev.resids = dev.resids,
                       aic = aic,
                       mu.eta = stats$mu.eta,
                       initialize = initialize,
                       validmu = validmu,
                       valideta = stats$valideta),
		  class = "family")
}
