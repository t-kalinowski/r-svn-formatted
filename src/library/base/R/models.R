formula <- function(x, ...) UseMethod("formula")
formula.default <- function (x)
{
	if (!is.null(x$formula))		eval(x$formula)
	else if (!is.null(x$call$formula))	eval(x$call$formula)
	else if (!is.null(x$terms))		x$terms
	else switch(mode(x),
                NULL = structure(NULL, class = "formula"),
		character = formula(eval(parse(text = x)[[1]])),
		call = eval(x), stop("invalid formula"))
}
formula.formula <- function(x) x
formula.terms <- function(x) {
	attributes(x) <- list(class="formula")
	x
}
print.formula <- function(x) print.default(unclass(x))

"[.formula" <- function(x,i) {
	ans <- NextMethod("[")
	if(as.character(ans[[1]]) == "~")
		class(ans) <- "formula"
	ans
}

terms <- function(x, ...) UseMethod("terms")
terms.default <- function(x) x$terms
terms.terms <- function(x, ...) x
print.terms <- function(x) print.default(unclass(x))
delete.response <- function (termobj)
{
	intercept <- if (attr(termobj, "intercept")) "1" else "0"
	terms(reformulate(c(attr(termobj, "term.labels"), intercept), NULL),
	      specials = names(attr(termobj, "specials")))
}

reformulate <- function (termlabels, response=NULL)
{
	termtext <- paste(termlabels, collapse="+")
	if (is.null(response)) {
		termtext <- paste("~", termtext, collapse="")
		eval(parse(text=termtext)[[1]])
	} else {
		termtext <- paste("response", "~", termtext, collapse="")
		termobj <- eval(parse(text=termtext)[[1]])
		termobj[[2]] <- response
		termobj
	}
}

drop.terms <-function(termobj, dropx=NULL, keep.response=FALSE)
{
 if (is.null(dropx))
	termobj
 else {
	newformula <- reformulate(attr(termobj, "term.labels")[-dropx],
				if (keep.response) termobj[[2]] else NULL)
	terms(newformula, specials=names(attr(termobj, "specials")))
 }
}

terms.formula <- function(x, specials = NULL, abb = NULL, data = NULL,
                          neg.out = TRUE, keep.order = FALSE)
{
  fixFormulaObject <- function(object) {
    tmp <- attr(terms(object), "term.labels")
    form <- formula(object)
    lhs <- if(length(form) == 2) NULL else deparse(form[[2]])
    rhs <- if(length(tmp)) paste(tmp, collapse = " + ") else "1"
    if(!attr(terms(object), "intercept")) rhs <- paste(rhs, "- 1")
    formula(paste(lhs, "~", rhs))
  }
  if (!is.null(data) && !is.environment(data) && !is.data.frame(data))
    data <- as.data.frame(data)
  new.specials <- unique(c(specials, "offset"))
  tmp <- .Internal(terms.formula(x, new.specials, abb, data, keep.order))
  ## need to fix up . in formulae in R
  terms <- fixFormulaObject(tmp)
  attributes(terms) <- attributes(tmp)
  offsets <- attr(terms, "specials")$offset
  if (!is.null(offsets)) {
    names <- dimnames(attr(terms, "factors"))[[1]][offsets]
    offsets <- match(names, dimnames(attr(terms, "factors"))[[2]])
    offsets <- offsets[!is.na(offsets)]
    if (length(offsets) > 0) {
      attr(terms, "factors") <- attr(terms, "factors")[, -offsets, drop = FALSE]
      attr(terms, "term.labels") <- attr(terms, "term.labels")[-offsets]
      attr(terms, "order") <- attr(terms, "order")[-offsets]
      attr(terms, "offset") <- attr(terms, "specials")$offset
    }
  }
  attr(terms, "specials")$offset <- NULL
  terms
}

coef <- function(x, ...) UseMethod("coef")
coef.default <- function(x, ...) x$coefficients
coefficients <- .Alias(coef)

residuals <- function(x, ...) UseMethod("residuals")
resid <- .Alias(residuals)

deviance <- function(x, ...) UseMethod("deviance")

fitted <- function(x, ...) UseMethod("fitted")
fitted.default <- function(x) x$fitted
fitted.values <- .Alias(fitted)

anova <- function(x, ...)UseMethod("anova")

effects <- function(x, ...)UseMethod("effects")

weights <- function(x, ...)UseMethod("weights")

df.residual <- function(x, ...)UseMethod("df.residual")

variable.names <-function(object, ...) UseMethod("variable.names")
variable.names.default <- .Alias(colnames)

case.names <-function(object, ...) UseMethod("case.names")
case.names.default <- .Alias(rownames)

offset <- function(x) x
## ?

na.action <- function(x, ...)UseMethod("na.action")
na.action.default <- function(x) attr(x, "na.action")

na.fail <- function(frame)
{
	ok <- complete.cases(frame)
	if(all(ok)) frame else stop("missing values in data frame");
}

na.omit <- function(frame)
{
	ok <- complete.cases(frame)
	if (all(ok))
		frame
	else frame[ok, ]
}

##-- used nowhere (0.62)
##- model.data.frame <- function(...) {
##-	cn <- as.character(substitute(list(...))[-1])
##-	rval<-data.frame(..., col.names=cn, as.is=TRUE)
##-	names(rval)<-cn
##-	rval
##- }

model.frame <- function(formula, ...)	UseMethod("model.frame")

model.frame.default <-
function(formula, data = NULL, subset=NULL, na.action = na.fail,
	 drop.unused.levels = FALSE, xlev = NULL,...)
{
	if(missing(formula)) {
		if(!missing(data) && inherits(data, "data.frame") &&
		length(attr(data, "terms")) > 0)
			return(data)
		formula <- as.formula(data)
	}
	else if(missing(data) && inherits(formula, "data.frame")) {
		if(length(attr(formula, "terms")))
			return(formula)
		data <- formula
		formula <- as.formula(data)
	}
	if(missing(na.action)) {
		if(!is.null(naa <- attr(data, "na.action")))
			na.action <- naa
		else if(!is.null(naa <- options("na.action")[[1]]))
			na.action <- naa
	}
	if(missing(data))
		data <- sys.frame(sys.parent())
	if(!inherits(formula, "terms"))
		formula <- terms(formula, data = data)
	rownames <- attr(data, "row.names")
        varnames <- as.character(attr(formula, "variables")[-1])
	variables <- eval(attr(formula, "variables"), data)
	extranames <- as.character(substitute(list(...))[-1])
        extras <- substitute(list(...))
	extras <- eval(extras, data)
        subset <- eval(substitute(subset), data)
	data <- .Internal(model.frame(formula, rownames, variables, varnames,
		extras, extranames, subset, na.action))
  # fix up the levels
  if(length(xlev) > 0) {
    for(nm in names(xlev))
      if(!is.null(xl <- xlev[[nm]])) {
	xi <- data[[nm]]
	if(is.null(nxl <- levels(xi)))
	  warning("variable", nm, "is not a factor")
	else {
	  xi <- xi[, drop= TRUE] # drop unused levels
	  if(any(m <- is.na(match(nxl, xl))))
	    stop("factor", nm, "has new level(s)", nxl[m])
	  data[[nm]] <- factor(xi, levels=xl)
	}
      }
  } else if(drop.unused.levels) {
    for(nm in names(data)) {
      x <- data[[nm]]
      if(is.factor(x) &&
	 length(unique(x)) < length(levels(x)))
	data[[nm]] <- data[[nm]][, drop = TRUE]
    }
  }
  data
}

model.weights <- function(x) x$"(weights)"
model.offset <- function(x) {
	offsets <- attr(attr(x, "terms"),"offset")
	if(length(offsets) > 0) {
		ans <- 0
		for(i in offsets) ans <- ans+x[[i]]
		ans
	}
	else NULL
}

model.matrix <- function(object, ...) UseMethod("model.matrix")
model.matrix.default <- function(formula, data = sys.frame(sys.parent()),
				 contrasts.arg = NULL, xlev = NULL)
{
 t <- terms(formula)
 if (is.null(attr(data, "terms")))
     data <- model.frame(formula, data, xlev=xlev)
 else {
   reorder <- match(as.character(attr(t,"variables"))[-1],names(data))
   if (any(is.na(reorder)))
     stop("model frame and formula mismatch in model.matrix()")
   data <- data[,reorder, drop=FALSE]
 }
 contr.funs <- as.character(.Options$contrasts)
 isF <- sapply(data, is.factor)[-1]
 isOF <- sapply(data, is.ordered)
 namD <- names(data)
 for(nn in namD[-1][isF]) # drop response
   if(is.null(attr(data[[nn]], "contrasts")))
     contrasts(data[[nn]]) <- contr.funs[1 + isOF[nn]]
## it might be safer to have numerical contrasts:
##	  get(contr.funs[1 + isOF[nn]])(nlevels(data[[nn]]))
 if (!is.null(contrasts.arg) && is.list(contrasts.arg)) {
   if (is.null(namC <- names(contrasts.arg)))
     stop("invalid contrasts argument")
   for (nn in namC) {
     if (is.na(ni <- match(nn, namD)))
       warning(paste("Variable", nn, "absent, contrast ignored"))
     else contrasts(data[[ni]]) <- contrasts.arg[[nn]]
   }
 }
 ans <- .Internal(model.matrix(t, data))
 cons <- if(any(isF))
   lapply(data[-1][isF], function(x) attr(x,  "contrasts"))
 else NULL
 attr(ans, "contrasts") <- cons
 ans
}
model.response <- function (data, type = "any")
{
  if (attr(attr(data, "terms"), "response")) {
    if (is.list(data) | is.data.frame(data)) {
      v <- data[[1]]
      if (type == "numeric" | type == "double") storage.mode(v) <- "double"
      else if (type != "any") stop("invalid response type")
      if (is.matrix(v) && ncol(v) == 1) dim(v) <- NULL
      rows <- attr(data, "row.names")
      if (nrows <- length(rows)) {
	if (length(v) == nrows) names(v) <- rows
	else if (length(dd <- dim(v)) == 2)
	  if (dd[1] == nrows && !length((dn <- dimnames(v))[[1]]))
	    dimnames(v) <- list(rows, dn[[2]])
      }
      return(v)
    } else stop("invalid data argument")
  } else return(NULL)
}
##model.response <- function (data, type = "any")
##{
##	if (attr(attr(data, "terms"), "response")) {
##		if (is.list(data) | is.data.frame(data)) {
##			v <- data[[1]]
##			if (type == "numeric" | type == "double") {
##				storage.mode(v) <- "double"
##			}
##			else if (type != "any")
##				stop("invalid response type")
##			if (is.matrix(v) && ncol(v) == 1)
##				dim(v) <- NULL
##			return(v)
##		}
##		else stop("invalid data argument")
##	}
##	else return(NULL)
##}

model.extract <- function (frame, component)
{
	component <- as.character(substitute(component))
	rval <- switch(component,
		response = model.response(frame),
		offset = model.offset(frame), weights = frame$"(weights)",
		start = frame$"(start)")
	if (is.null(rval)) {
		name <- paste("frame$\"(", component, ")\"", sep = "")
		rval <- eval(parse(text = name)[1])
	}
	if(!is.null(rval)){
	  if (length(rval) == nrow(frame))
	    names(rval) <- attr(frame, "row.names")
	  else if (is.matrix(rval) && nrow(rval) == nrow(frame)) {
	    t1 <- dimnames(rval)
	    dimnames(rval) <- list(attr(frame, "row.names"), t1[[2]])
	  }
	}
	return(rval)
}

preplot <- function(object, ...) UseMethod("preplot")
update <- function(object, ...) UseMethod("update")

is.empty.model<-function (x)
{
	tt <- terms(x)
	(length(attr(tt, "factors")) == 0) & (attr(tt, "intercept")==0)
}
