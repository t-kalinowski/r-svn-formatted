prop.test <- function(x, n, p = NULL, alternative = "two.sided",
		      conf.level = 0.95, correct = TRUE)
{
  DNAME <- paste(deparse(substitute(x)), "out of", deparse(substitute(n)))

  if ((l <- length(x)) != length(n))
    stop("x and n must have the same length")
  OK <- complete.cases(x, n)
  x <- x[OK]
  n <- n[OK]
  if ((k <- length(x)) < 1)
    stop("Not enough data")
  if (any(n <= 0))
    stop("Elements of n must be positive")
  if (any(x < 0))
    stop("Elements of x must be nonnegative")
  if (any(x > n))
    stop("Elements of x must not be greater than those of n")

  if (is.null(p) && (k == 1))
    p <- .5
  if (!is.null(p)) {
    DNAME <- paste(DNAME, ", null ",
		   ifelse(k == 1, "probability ", "probabilities "),
		   deparse(substitute(p)), sep = "")
    if (length(p) != l)
      stop("p must have the same length as x and n")
    p <- p[OK]    
    if (any((p <= 0) | (p >= 1)))
      stop("Elements of p must be in (0,1)")
  }

  CHOICES <- c("two.sided", "less", "greater")
  alternative <- CHOICES[pmatch(alternative, CHOICES)]
  if (length(alternative) > 1 || is.na(alternative)) 
    stop("alternative must be \"two.sided\", \"less\" or \"greater\"")
  if ((k > 2) || (k == 2) && !is.null(p))
    alternative <- "two.sided"

  if ((length(conf.level) != 1) || is.na(conf.level) ||
      (conf.level <= 0) || (conf.level >= 1))
    stop("conf.level must be a single number between 0 and 1")

  correct <- as.logical(correct)
  
  ESTIMATE <- x/n
  names(ESTIMATE) <- if (k == 1) "p" else paste("prop", 1:l)[OK]
  NVAL <- p
  CINT <- NULL
  YATES <- ifelse(correct && (k <= 2), .5, 0)

  if (k == 1) {
    z <- ifelse(alternative == "two.sided",
		qnorm((1 + conf.level) / 2),
		qnorm(conf.level))
    YATES <- min(YATES, abs(x - n * p))
    p.c <- ESTIMATE + YATES / n
    p.u <- ((p.c + z^2 / (2 * n) 
	     + z * sqrt(p.c * (1 - p.c) / n + z^2 / (4 * n^2)))
	    / (1 + z^2 / n))
    p.c <- ESTIMATE - YATES / n
    p.l <- ((p.c + z^2 / (2 * n) 
	     - z * sqrt(p.c * (1 - p.c) / n + z^2 / (4 * n^2)))
	    / (1 + z^2 / n))
    CINT <- switch(alternative,
		   "two.sided" = c(max(p.l, 0), min(p.u, 1)),
		   "greater" = c(max(p.l, 0), 1),
		   "less" = c(0, min(p.u, 1)))
  }
  else if ((k == 2) & is.null(p)) {
    DELTA <- ESTIMATE[1] - ESTIMATE[2]
    YATES <- min(YATES, abs(DELTA) / sum(1/n))
    WIDTH <- (switch(alternative,
		     "two.sided" = qnorm((1 + conf.level) / 2),
		     qnorm(conf.level))
	      * sqrt(sum(ESTIMATE * (1 - ESTIMATE) / n))
	      + YATES * sum(1/n))
    CINT <- switch(alternative,
		   "two.sided" = c(max(DELTA - WIDTH, -1),
		                   min(DELTA + WIDTH, 1)),
		   "greater" = c(max(DELTA - WIDTH, -1), 1),
		   "less" = c(-1, min(DELTA + WIDTH, 1)))
  }
  if (!is.null(CINT))
    attr(CINT, "conf.level") <- conf.level

  METHOD <- paste(ifelse(k == 1,
			 "1-sample proportions test",
			 paste(k, "-sample test for ",
			       ifelse(is.null(p), "equality of", "given"),
			       " proportions", sep = "")),
		  ifelse(YATES, "with", "without"),
		  "continuity correction")

  if (is.null(p)) {
    p <- sum(x)/sum(n)
    PARAMETER <- k - 1
  }
  else {
    PARAMETER <- k
    names(NVAL) <- names(ESTIMATE)
  }
  names(PARAMETER) <- "df"

  x <- cbind(x, n - x)
  E <- cbind(n * p, n * (1 - p))
  if (any(E < 5))
    warning("Chi-square approximation may be incorrect")
  STATISTIC <- sum((abs(x - E) - YATES)^2 / E)
  names(STATISTIC) <- "X-squared"

  if (alternative == "two.sided")
    PVAL <- 1 - pchisq(STATISTIC, PARAMETER)
  else {
    if (k == 1)
      z <- sign(ESTIMATE - p) * sqrt(STATISTIC)
    else
      z <- sign(DELTA) * sqrt(STATISTIC)
    if (alternative == "greater")
      PVAL <- 1 - pnorm(z)
    else
      PVAL <- pnorm(z)
  }

  RVAL <- list(statistic = STATISTIC,
	       parameter = PARAMETER,
	       p.value = PVAL,
	       estimate = ESTIMATE,
	       null.value = NVAL,
	       conf.int = CINT,
	       alternative = alternative,
	       method = METHOD,
	       data.name = DNAME)
  class(RVAL) <- "htest"
  return(RVAL)
}
