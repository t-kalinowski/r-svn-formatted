as <-
  ## Returns the version of this object coerced to be the given `Class'.  
  ## If the corresponding `is' relation is true, it will be used.  In particular,
  ## if the relation has a coerce method, the method will be invoked on `object'.
  ##
  ## If the `is' relation is FALSE, and `coerceFlag' is `TRUE',
  ## the coerce function will be called (which will throw an error if there is
  ## no valid way to coerce the two objects).  Otherwise, `NULL' is returned.
  function(object, Class, coerceFlag = T) {
    thisClass <- data.class(object)
    if(thisClass == Class)
      return(object)
    if(is(object, Class)) {
      ## look for coerce method or indirection
      coe <- extendsCoerce(thisClass, Class)
      coe(object)
    }
    else if(coerceFlag) {
      f <- elNamed(asFunctions, Class)
      if(is.function(f))
        f(object)
      else
        coerce(object, new(Class, .Force=T))
    }
    else
      NULL
  }

coerce <-
  ## Coerce `x' to be of the same class as `y'.  Not a function you should usually
  ## call explicitly.  Methods for this function are generated by `setAs'.
  function(x, y) {
    toClass <- data.class(y)
    if(!is.na(match(toClass, .BasicVectorClasses)))
      value <- as.vector(x, toClass)
    else if(isClass(toClass)) {
      value <- NULL
      fromClass <- data.class(x)
      if(isClass(fromClass)) {
        if(identical(slotNames(fromClass), slotNames(toClass)))
          value <- x
      }
      else if(data.class(getPrototype(getClass(toClass))) == fromClass)
        value <- x
    }
    if(is.null(value))
      stop(paste("Unable to perform default coerce from \"",
                 data.class(x), "\" to \"", toClass, "\"", sep=""))
    data.class(value) <- toClass
    value
  }

"as<-" <-
  ## Set the portion of the object defined by the right-hand side.  
  ##
  ## Typically, the object being modified extends the class of the right-hand side object,
  ## and contains the slots of that object. These slots (only) will then be replaced.
  function(object, Class, coerce = T, value) {
    ## TODO:  examine the extends relation to find a replace method.
    ## Meanwhile, handle the case of slot containment
    if(coerce && !identical(data.class(value), Class))
      value <- as(value, Class)
    if(is(object, Class)) {
      slots <- slotNames(Class)
      if(length(slots)>0) {
        for(what in slots)
          slot(object, what) <- slot(value, what)
      }
      ## should check here that this is the only superClass of object
      ## (needs a version of the extends function with 1 arg that uses
      ## only the direct definition, not the completion).
      else {
        class(value) <- Class
        object <- value
      }
    }
    else
      stop("Non-extension version of as(...) <- not yet implemented.")
    object
  }
    

asFunctions <- list(
  array = as.array,
  call = as.call,
  character = as.character,
  complex = as.complex,
  data.frame = as.data.frame,
  double = as.double,
  expression = as.expression,
  factor = as.factor,
  formula = as.formula,
  "function" = as.function,
  integer = as.integer,
  list = as.list,
  logical = as.logical,
  matrix = as.matrix,
  name = as.name,
  null = as.null,
  numeric = as.numeric,
  ordered = as.ordered,
  pairlist = as.pairlist,
  real = as.real,
  single = as.single,
  symbol = as.symbol,
  table = as.table,
  ts = as.ts
  )
  
