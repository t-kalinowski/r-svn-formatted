as <-
  ## Returns the version of this object coerced to be the given `Class'.
  ## If the corresponding `is' relation is true, it will be used.  In particular,
  ## if the relation has a coerce method, the method will be invoked on `object'.
  ##
  ## If the `is' relation is FALSE, and `coerceFlag' is `TRUE',
  ## the coerce function will be called (which will throw an error if there is
  ## no valid way to coerce the two objects).  Otherwise, `NULL' is returned.
  function(object, Class, strict = TRUE)
{
    thisClass <- .class1(object) ## always one string
    if(thisClass == Class)
        return(object)
    asMethod <- .quickCoerceSelect(thisClass, Class)
    if(is.null(asMethod)) {
        sig <-  c(from=thisClass, to = Class)
        canCache <- TRUE
        asMethod <- selectMethod("coerce", sig, TRUE, c(from = TRUE, to = FALSE)) #optional, no inheritance
        if(is.null(asMethod)) {
            if(is(object, Class)) {
                asMethod <- possibleExtends(thisClass, Class)
                if(identical(asMethod, FALSE))
                    stop("Internal problem in as():  \"", thisClass, "\" is(object, \"",
                         Class, "\) is TRUE, but the metadata asserts that the is relation is FALSE")
                else if(identical(asMethod, TRUE)) 
                    asMethod <- .makeAsMethod(quote(from), TRUE, Class)
                else {
                    test <- asMethod@test
                    asMethod <- .makeAsMethod(asMethod@coerce, asMethod@simple, Class)
                    canCache <- (!is(test, "function")) || identical(body(test), TRUE)
                }
            }
            if(is.null(asMethod) && extends(Class, thisClass))
                asMethod <- .asFromReplace(thisClass, Class)
            if(is.null(asMethod))
                asMethod <- selectMethod("coerce", sig, TRUE, c(from = TRUE, to = FALSE))
        }
        ## cache for next call
        if(canCache && !is.null(asMethod))
            cacheMethod("coerce", sig, asMethod)
    }
    if(is.null(asMethod))
        stop(paste("No method or default for coercing \"", thisClass,
                       "\" to \"", Class, "\"", sep=""))
    else if(strict)
        asMethod(object)
    else
        asMethod(object, strict = FALSE)
}

.quickCoerceGetsSelect <- function(from, to) {
    methods <- getMethodsForDispatch("coerce<-")
    allMethods <- methods@allMethods
    method <- allMethods[[from]]
    if(is.null(method))
        method
    else
        method@allMethods[[to]]
}

.quickCoerceSelect <- function(from, to) {
    methods <- getMethodsForDispatch("coerce")
    allMethods <- methods@allMethods
    method <- allMethods[[from]]
    if(is.null(method))
        method
    else
        method@allMethods[[to]]
}

.asFromReplace <- function(fromClass, toClass) {
    ## toClass extends fromClass, so an asMethod will
    ## be the equivalent of new("toClass", fromObject)
    ## But must check that replacement is defined, in the case
    ## of nonstandard superclass relations
    replaceMethod <- elNamed(getClass(toClass)@contains, fromClass)
    if(is(replaceMethod, "SClassExtension") &&
       !identical(as(replaceMethod@replace, "function"), .ErrorReplace)) {
        f <- .ErrorReplace
        body(f, envir = environment(f)) <-
            substitute({obj <- new(TOCLASS); as(obj, FROMCLASS) <- value; obj},
                       list(FROMCLASS = fromClass, TOCLASS = toClass))
        f
    }
    else
        NULL
        
}



"as<-" <-
  ## Set the portion of the object defined by the right-hand side.
  ##
  ## Typically, the object being modified extends the class of the right-hand side object,
  ## and contains the slots of that object. These slots (only) will then be replaced.
  function(object, Class, value) {
    thisClass <- .class1(object)
    if(!identical(.class1(value), Class))
      value <- as(value, Class)
    asMethod <- .quickCoerceGetsSelect(thisClass, Class)
    if(is.null(asMethod)) {
    sig <-  c(from=thisClass, to = Class)
    canCache <- TRUE
    asMethod <- selectMethod("coerce<-", sig, TRUE, FALSE) #optional, no inheritance
    if(is.null(asMethod)) {
        if(is(object, Class)) {
            asMethod <- possibleExtends(thisClass, Class)
            if(identical(asMethod, TRUE)) {# trivial, probably identical classes
                class(value) <- class(object)
                return(value)
            }
            else {
                test <- asMethod@test
                asMethod <- asMethod@replace
                canCache <- (!is(test, "function")) || identical(body(test), TRUE)
           }
         }
        else
            asMethod <- selectMethod("coerce<-", sig, TRUE, c(from = TRUE, to = FALSE))
    }
        ## cache for next call
        if(canCache && !is.null(asMethod))
            cacheMethod("coerce<-", sig, asMethod)
    
    }
    if(is.null(asMethod))
        stop(paste("No method or default for as() replacement of \"", thisClass,
                   "\" with Class=\"", Class, "\"", sep=""))
    asMethod(object, Class, value)
}



setAs <- 
  function(from, to, def, replace = NULL, where = .topLevelEnv())
  {
    ## where there is an "is" relation, modify it
    if(extends(from, to, TRUE)) {
      extds <- getClassDef(from)@contains
      if(is.list(extds)) {
        test <- elNamed(extds, "test")
        if(missing(replace))
          replace <- elNamed(extds, "replace")
      }
      else
        test <- NULL
      setIs(from, to, test = test, coerce = def, replace = replace, where = where)
    }
    else {
      args <- formalArgs(def)
      if(!is.na(match("strict", args))) args <- args[-match("strict", args)]
      if(length(args) == 1)
          def <- substituteFunctionArgs(def, "from")
      else if(length(args) == 2)
          def <- substituteFunctionArgs(def, c("from", "to"))
      else stop(paste("as method must have one or two arguments, plus optional `strict'; got (",
                      paste(formalArgs(def), collapse = ", "), ")", sep=""))
      method <- as.list(coerce@.Data) # the function def'n, just to get arguments correct
      method$to <- to
      method <- as.function(method)
      body(method, envir = environment(def)) <- body(def)
      setMethod("coerce", c(from, to), method, where = where)
      if(!is.null(replace)) {
        args <- formalArgs(replace)
        if(length(args) != 2)
          stop("a replace method definition in setAs must be a function of two arguments")
        replace <- body(replace)
        if(!identical(args, c("from", "value"))) {
          ll <- list(quote(from), quote(value))
          names(ll) <- args
          replace <- substituteDirect(replace, ll)
          warning("Argument names in replace changed to agree with \"coerce<-\" generic:\n",
                  paste(deparse(bdy), sep="\n    "), "\n")
        }
        method <- eval(function(from, to, value)NULL)
        functionBody(method, envir = .GlobalEnv) <- replace
        setMethod("coerce<-", c(from, to), method, where = where)
      }
    }
  }

.setCoerceGeneric <- function(where) {
  ## create the initial version of the coerce function, with methods that convert
  ## arbitrary objects to the basic classes by calling the corresponding as.<Class>
  ## functions.
  setGeneric("coerce", function(from, to, strict = TRUE)standardGeneric("coerce"),
             where = where)
  setGeneric("coerce<-", function(from, to, value)standardGeneric("coerce<-"), where = where)
  basics <- c(
 "POSIXct",  "POSIXlt",  "array",  "call",  "character",  "complex",  "data.frame", 
 "environment",  "expression",  "factor",  "formula",  "function",  "integer", 
 "list",  "logical",  "matrix",  "name",  "numeric",  "ordered", 
  "single",  "table",  "ts",  "vector")
  basics <- basics[!is.na(match(basics,.BasicClasses))]
  for(what in basics) {
      ## if the class is a basic class and there exists an as.<class> function,
      ## use it as the coerce method.
      method  <- .basicCoerceMethod
      switch(what,
                  array =, matrix = body(method, envir = environment(method)) <- substitute({
          value <- AS(from)
          if(strict) {
              dm <- dim(value)
              dn <- dimnames(value)
              attributes(value) <- NULL
              dim(value) <- dm
              dimnames(value) <- dn
          }
          value
          }, list(AS = as.name(paste("as.", what, sep="")))),
                   ts = body(method, envir = environment(method)) <- quote({
          value <- as.ts(from)
          if(strict) {
              attributes(value) <- NULL
              class(value) <- "ts"
              tsp(value) <- tsp(from)
          }
          value
          }),
             ## default: no attributes
             body(method, envir = environment(method)) <- substitute({
          value <- AS(from)
          if(strict)
              attributes(value) <- NULL
          value
          }, list(AS = as.name(paste("as.", what, sep=""))))
                  )
      setMethod("coerce", c("ANY", what), method, where = where)
  }
  ## and some hand-coded ones
  body(method) <- quote(as.null(from))
  setMethod("coerce", c("ANY", "NULL"), method)
  body(method) <- quote({
            if(length(from) != 1)
              warning("ambiguous object (length!=1) to coerce to \"name\"")
            as.name(from)
        })
  setMethod("coerce", c("ANY","name"), method)
  ## not accounted for and maybe not needed:  real, pairlist, double
}

.basicCoerceMethod <- function(from, to, strict = TRUE) stop("Undefined coerce method")

.makeAsMethod <- function(expr, simple, Class) {
    if(is(expr, "function")) {
        args <- formalArgs(expr)
        if(!identical(args, "from"))
            expr <- .ChangeFormals(expr,
                    if(length(args) > 1) .simpleExtCoerce else .simpleIsCoerce)
        expr <- body(expr)
    }
    if(isVirtualClass(getClass(Class)))
        value <- expr
    else if(identical(expr, quote(from)))
        value <- substitute({class(from) <- CLASS; from},
                           list(CLASS = Class))
    else value <- substitute({from <- EXPR; class(from) <- CLASS; from},
                           list(EXPR = expr, CLASS = Class) )
    if(simple && !identical(expr, quote(from)))
        value <- substitute(if(strict) EXPR else from,
                           list(EXPR = expr))
    f <- .simpleExtCoerce
    body(f, envir = environment(f)) <- value
    f
}
