<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>Methods for the Subset Functions</title>
<link REL=stylesheet HREF=../../Docs/OmegaTech.css>
</head>

<body>
<h1>Methods for the Subset Functions</h1>

Formal methods for the subset methods (the <code>[]</code> and
<code>[[]]</code> operators and their replacement counterparts) have
to overcome two problems:

<ol>
  <li> The non-generic definitions of these functions are primitives,
      meaning that the default methods will also be primitive and will
      have to be evaluated correctly for that form (as opposed to an
      ordinary closure).<p>
  <li> Unlike the other primitives that might be candidates for formal
      methods (math functions, binary operators), the subset functions
      take in principle an arbitrary number of arguments.  The code
      implementing the primitives tries to deal with the actual
      argument list; e.g., trying to detect extra arguments when
      selecting from non-arrays.
</ol>

To see the problem with primitive functions generally, here is a
summary of what happens when a function is made into a generic
function, typically by calling <code>setMethod</code> to define a
method for it.  Let's take the function <code>length</code> as an
example.

<ul>
  <li>
      A definition for the generic function is created, in this case
      <pre><code>
      function(x) standardGeneric("length")
      </code></pre><p>
  <li>
      The methods for the function are organized into an object that
      is stored in the environment of the generic function.  In
      particular, the previous non-generic definition will become the
      default method, in this example, <code>.Primitive("length")</code>.<p>
  <li>
      A call, <code>length(myObject)</code>, say, will now call the
      generic function and hence <code>standardGeneric</code>.  The
      implementation of <code>standardGeneric</code> looks through the
      methods object, evaluating arguments in the call to the generic
      as needed, until it selects one method (maybe the default).<p>
  <li> The selected method is then evaluated:  the goal is that the
      effect will be the same as if the call to the generic had been a
      call to this method, with the same arguments.
</ul>
<p>
It's the last step that creates complications in the case of methods
that are primitives.  For methods that are closures (ordinary functions), all that is
involved is evaluating the body of the method in the context of the
generic.  By definition, methods are supposed to have the same formal
argument list as the generic.  (S-Plus relaxes this by creating an
internal version of the actual method if the arguments don't match.  R
could do the same if we want, but it's not clearly a good idea.)
<p>
For primitives, the situation is different.  The call to the primitive
does not create a frame, so the notion of ``evaluating the body in the
frame''
makes no sense.  Something else must be done to simulate the original
call to the primitive non-generic function.
<p>
There seem to be three ways to do this, each of them with attractions
and difficulties:
<ol>
  <li> A call to the primitive can be generated from the frame of the
      generic, passing down the formal arguments of the generic as
      actual arguments to the primitive.  In the case of
      <code>length</code>, the effect would be equivalent to
      <p>
<pre><code>
      (.Primitve("length"))(x)
      </code></pre>
      <p>
  <li> A call to the primitive can be generated with the actual
      arguments of the call to the generic, and evaluated in the frame
      of the caller to the generic.  In the example, the effect would
      be equivalent to
      <p>
<pre><code>
      (.Primitve("length"))(myObject)
      </code></pre>
      but evaluated in the caller's frame, of course.
      <p>
  <li> The third option is essentially the way S3 methods are
      currently evaluated.  The code for the primitive is modified to
      precede its calculations with an attempt to dispatch a method
      for the generic function.  If this attempt would have evaluated
      the default method, it doesn't, but instead returns an
      indication to the primitive code that no overriding method
      applies.  The primitive code then goes on to do its normal computations.
</ol>
<p>
So, what's good and bad here?
<ol>
  <li> This implementation is simple and efficient.  The call to be
      evaluated can be precomputed and stored in the metadata; it just
      then needs to be pulled out and evaluated.<p>
      The catch is that it doesn't work for the subset functions,
      because the corresponding primitive code looks at the actual
      argument list to decide if there are too many arguments for the
      object in question, etc.  This doesn't work, because we want to
      define the generic to allow methods to dispatch at least on the
      row and column index arguments, so the generic has a form like:
      <p>
<pre><code>
      function(x, i, j, ..., drop = FALSE)
        standardGeneric("[")
      </code></pre>
      The primitive code thinks it gets two or more index arguments,
      and generates an error.
      <p>
  <li> The second implementation solves that problem, and generally
      allows the primitives to act as if they had been called directly.<p>
      In this case there are two catches.  At the moment, while this
      approach seems to work most of the time, it seems to get into
      trouble finding the right frame when the intervening call
      involves a <code>.Internal</code> (e.g, in a call to
      <code>lapply</code>).  Chances are I'm just not doing this
      right, or else there is some problem with the internal
      implementation of the "<code>sys.</code>" family of functions.
      <p>
      A more serious difficulty seems to be controlling re-evaluation
      of arguments.  Inside the evaluator, the arguments to an
      ordinary function are wrapped in promises, and the routine
      <code>appllyClosure</code> then operates on the promises,
      guaranteeing that any evaluated arguments have their values
      stored in the promise structure, avoiding re-evaluation.
      <p>
      In this example, however, some formal arguments to the generic
      need to be evaluated during method selection.  Their values are
      not (I don't think) reflected in any promise structure that is
      retained for later use.  To ensure that arguments don't get
      evaluated again, a promise structure would need to be associated
      with the object representing the call to the generic, so this
      structure could be used <i>each</i> time some evaluation was needed.<p>
  <li>
      The approach used currently to evaluate S3-style methods could
      be extended to S4 methods.  There are some trickier details than
      with S3 methods, related to just the issues mentioned above
      about avoiding repeated evaluation.<p>
      However, this approach seems undesirable for a more fundamental
      reason.  To make it work, one must <i>avoid</i> creating
      ordinary generic functions for the current primitives.  As a
      result, we end up with two approaches to methods at a pretty
      high level, based only on the accident that some functions are
      currently implemented as primitives.  Such an artificial
      distinction seems very likely to bite us (and even more, other
      users) in the future.
      
</ol>

<hr>
<address><a href="http://cm.bell-labs.com/cm/ms/departments/sia/jmc/">John Chambers</a><a href=mailto:jmc@research.bell-labs.com>&lt;jmc@research.bell-labs.com&gt;</a></address>
<!-- hhmts start -->
Last modified: Mon Jul  2 18:25:12 EDT 2001
<!-- hhmts end -->
</body> </html>
