## based on, especially multivariate case, code by Martyn Plummer
ar <-
    function (x, aic = TRUE, order.max = NULL, method=c("yule-walker","burg"),
              na.action = na.fail, series = deparse(substitute(x)))
{
    res <- switch(match.arg(method),
        "yule-walker" = ar.yw(x, aic=aic, order.max=order.max,
                              na.action = na.action, series=series),
	"burg" = ar.burg(x, aic=aic, order.max=order.max,
                              na.action = na.action, series=series)
    )
    res$call <- match.call()
    res
}

ar.burg <- function (x, aic = TRUE, order.max = NULL, na.action = na.fail,
                   series = deparse(substitute(x)))
    .NotYetImplemented()

ar.yw <- function (x, aic = TRUE, order.max = NULL, na.action = na.fail,
                   series = deparse(substitute(x)))
{
    x <- na.action(x)
    xfreq <- frequency(as.ts(x))
    if(ists <- is.ts(x)) xtsp <- tsp(x)
    x <- as.matrix(x)
    if(any(is.na(x))) stop("NAs in x")
    xm <- apply(x, 2, mean)
    x <- sweep(x, 2, xm)
    n.used <- nrow(x)
    nser <- ncol(x)
    order.max <- if (is.null(order.max)) floor(10 * log10(n.used))
                 else round(order.max)
    if (order.max < 1) stop("order.max must be >= 1")
    xacf <- acf(x, type = "covariance", lag.max = order.max, plot=FALSE)$acf
    if(nser > 1) {
        ## multivariate case
        snames <- colnames(x)
        A <- B <- array(0, dim = c(order.max + 1, nser, nser))
        A[1, , ] <- B[1, , ] <- diag(nser)
        EA <- EB <- xacf[1, , , drop = TRUE]
        partialacf <- array(dim = c(order.max, nser, nser))
        xaic <- numeric(order.max + 1)
        solve.yw <- function(m) {
            # Solve Yule-Walker equations with Whittle's
            # generalization of the Levinson(-Durbin) algorithm
            betaA <- betaB <- 0
            for (i in 0:m) {
                betaA <- betaA + A[i + 1, , ] %*% xacf[m + 2 - i, , ]
                betaB <- betaB + B[i + 1, , ] %*% t(xacf[m + 2 - i, , ])
            }
            KA <- -t(qr.solve(t(EB), t(betaA)))
            KB <- -t(qr.solve(t(EA), t(betaB)))
            EB <<- (diag(nser) - KB %*% KA) %*% EB
            EA <<- (diag(nser) - KA %*% KB) %*% EA
            Aold <- A
            Bold <- B
            for (i in 1:(m + 1)) {
                A[i + 1, , ] <<- Aold[i + 1, , ] + KA %*% Bold[m + 2 - i, , ]
                B[i + 1, , ] <<- Bold[i + 1, , ] + KB %*% Aold[m + 2 - i, , ]
            }
        }
        cal.aic <- function()
        {
            det <- abs(prod(diag(qr(var.pred)$qr)))
            return(n.used * log(det) + 2 * m * nser * nser)
        }
        cal.var.pred <- function()
        {
            vp <- 0
            for (i in 0:m)
                for (j in 0:m) {
                    R <- xacf[abs(i - j) + 1, , ]
                    if (j < i) R <- t(R)
                    vp <- vp + A[i + 1, , ] %*% R %*% t(A[j + 1, , ])
                }
            #Splus compatibility fix
            vp * n.used/(n.used - nser * (m + 1))
        }
        cal.resid <- function()
        {
            resid <- array(dim = c(n.used, nser))
            fitted <- array(0, dim = c(n.used - order, nser))
            if (order > 0) {
                A <- array(dim = c(nser, nser))
                for (i in 1:order) {
                    A[, ] <- ar[i, , , drop = FALSE]
                    fitted <- fitted +
                        x[(order - i + 1):(n.used - i), , drop = FALSE] %*% t(A)
                }
            }
            resid[(order + 1):n.used, ] <-
                x[(order + 1):n.used, , drop = FALSE] - fitted
            colnames(resid) <- snames
            return(resid)
        }
        ar.list <- vector("list", order.max)
        for (m in 0:order.max) {
            var.pred <- cal.var.pred()
            xaic[m + 1] <- cal.aic()
            if (m < order.max) {
                solve.yw(m)
                partialacf[m + 1, , ] <- -A[m + 2, , ]
                ar.list[[m + 1]] <- -A[2:(m + 2), , , drop = FALSE]
            }
        }
        xaic <- xaic - min(xaic)
        names(xaic) <- 0:order.max
        order <- if (aic) (0:order.max)[xaic == 0] else order.max
        ar <- if (order > 0) ar.list[[order]] else array(0, dim = c(1, nser, nser))
        dimnames(ar) <- list(1:order, snames, snames)
        dimnames(var.pred) <- list(snames, snames)
        dimnames(partialacf) <- list(1:order.max, snames, snames)
        resid <- cal.resid()
    } else {
        ## univariate case
        r <- as.double(drop(xacf))
        z <- .Fortran("eureka",
                      as.integer(order.max),
                      r, r,
                      coefs=double(order.max^2),
                      vars=double(order.max),
                      double(order.max))
        coefs <- matrix(z$coefs, order.max, order.max)
        partialacf <- array(diag(coefs), dim=c(order.max, 1, 1))
        var.pred <- c(r[1], z$vars)
        xaic <- n.used * log(var.pred) + 2 * (0:order.max)
        xaic <- xaic - min(xaic)
        names(xaic) <- 0:order.max
        order <- if (aic) (0:order.max)[xaic == 0] else order.max
        ar <- if (order > 0) coefs[order,1:order] else 0
        var.pred <- var.pred[order+1]
        ## Splus compatibility fix
        var.pred <- var.pred * n.used/(n.used - (order + 1))
        if(order > 0)
            resid <- c(rep(NA, order), embed(x, order+1) %*% c(1, -ar))
        else resid <- as.vector(x)
        if(ists) {
            attr(resid, "tsp") <- xtsp
            attr(resid, "class") <- "ts"
        }
    }
    res <- list(order=order, ar=ar, var.pred=var.pred, x.mean= drop(xm),
                aic = xaic, n.used=n.used, order.max=order.max,
                partialacf=partialacf, resid=resid, method = "Yule-Walker",
                series=series, frequency=xfreq, call=match.call())
    if(nser == 1)
        res$asy.var.coef <- solve(toeplitz(drop(xacf)[1:order]))*var.pred/n.used
    class(res) <- "ar"
    res
}

print.ar <- function(x, digits = max(3, .Options$digits - 3), ...)
{
    cat("\nCall:\n", deparse(x$call), "\n\n", sep = "")
    nser <- NCOL(x$var.pred)
    if(nser > 1) {
        res <- x[c("ar", "var.pred")]
        res$ar <- aperm(res$ar, c(2,3,1))
        print(res, digits=digits)
    } else {
        cat("Coefficients:\n")
        coef <- round(x$ar, digits = digits)
        names(coef) <- 1:x$order
        print.default(coef, print.gap = 2)
        cat("\nOrder selected", x$order, " sigma^2 estimated as ",
            format(x$var.pred, digits = digits),"\n")

    }
    invisible(x)
}

predict.ar <- function(object, newdata, n.ahead = 1, se.fit=TRUE, ...)
{
    if(missing(newdata)) newdata <- eval(parse(text=object$series))
    nser <- NCOL(newdata)
    ar <- object$ar
    p <- object$order
    st <- tsp(as.ts(newdata))[2]
    dt <- deltat(newdata)
    xfreq <- frequency(newdata)
    tsp(newdata) <- NULL
    class(newdata) <- NULL
    if(NCOL(ar) != nser)
        stop("number of series in fit and newdata do not match")
    n <- NROW(newdata)
    if(nser > 1) {
        x <- rbind(newdata, matrix(newdata[n, ], n.ahead, nser, byrow=TRUE))
        if(p > 0) {
            for(i in 1:n.ahead) {
                x[n+i,] <- x[n+i-1,] %*% ar[1,,]
                if(p > 1) for(j in 2:p)
                    x[n+i,] <- x[n+i,] + x[n+i-j,] %*% ar[j,,]
            }
            pred <- x[n+(1:n.ahead), ]
        } else {
            pred <- matrix(0, n.ahead, nser)
        }
        pred <- pred + matrix(object$x.mean, n.ahead, nser, byrow=TRUE)
        colnames(pred) <- colnames(jj$var.pred)
        if(se.fit) {
            warn("se.fit not yet implemented for multivariate models")
            se <- array(NA, dim=c(n.ahead, nser, nser))
        }
    } else {
        x <- c(newdata-object$x.mean, rep(0, n.ahead))
        if(p > 0) {
            for(i in 1:n.ahead) {
                x[n+i] <- sum(ar * x[n+i - (1:p)])
            }
            pred <- x[n+(1:n.ahead)]
            if(se.fit) {
                npsi <- n.ahead - 1
                psi <- .C("artoma",
                        as.integer(object$order), as.double(ar),
                        psi = double(npsi+object$order+1),
                        as.integer(npsi))$psi[1:npsi]
                vars <- cumsum(c(1, psi^2))
                se <- sqrt(object$var.pred*vars)
            }
        } else {
            pred <- rep(0, n.ahead)
            if (se.fit) se <- rep(sqrt(object$var.pred), n.ahead)
        }
        pred <- pred + rep(object$x.mean, n.ahead)
    }
    pred <- ts(pred, start = st + dt, frequency=xfreq)
    if(se.fit) return(pred, se) else return(pred)
}
