
R version 2.6.0 Under development (unstable) (2007-04-24 r41305)
Copyright (C) 2007 The R Foundation for Statistical Computing
ISBN 3-900051-07-0

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ## tests of R functions based on the lapack module
> 
> ##    -------  examples from ?svd using La.svd ---------
> 
> hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, "+") }
> Eps <- 100 * .Machine$double.eps
> 
> X <- hilbert(9)[,1:6]
> str(s <- La.svd(X)); D <- diag(s$d)
List of 3
 $ d : num [1:6] 1.67e+00 2.77e-01 2.22e-02 1.08e-03 3.24e-05 ...
 $ u : num [1:9, 1:6] -0.724 -0.428 -0.312 -0.248 -0.206 ...
 $ vt: num [1:6, 1:6] -0.7365  0.6225  0.2550 -0.0698  0.0133 ...
> stopifnot(abs(X - s$u %*% D %*% s$vt) < Eps)#  X = U D V'
> stopifnot(abs(D - t(s$u) %*% X %*% t(s$vt)) < Eps)#  D = U' X V
> 
> X <- cbind(1, 1:7)
> str(s <- La.svd(X)); D <- diag(s$d)
List of 3
 $ d : num [1:2] 12.07  1.16
 $ u : num [1:7, 1:2] 0.0976 0.1788 0.2601 0.3413 0.4225 ...
 $ vt: num [1:2, 1:2]  0.198  0.980  0.980 -0.198
> stopifnot(abs(X - s$u %*% D %*% s$vt) < Eps)#  X = U D V'
> stopifnot(abs(D - t(s$u) %*% X %*% t(s$vt)) < Eps)#  D = U' X V
> 
> # test nu and nv
> La.svd(X, nu = 0)
$d
[1] 12.068734  1.160022

$vt
          [,1]       [,2]
[1,] 0.1979452  0.9802131
[2,] 0.9802131 -0.1979452

> (s <- La.svd(X, nu = 7))
$d
[1] 12.068734  1.160022

$u
          [,1]         [,2]        [,3]        [,4]        [,5]       [,6]
[1,] 0.0976207  0.674355925 -0.38313920 -0.35392400 -0.32470879 -0.2954936
[2,] 0.1788399  0.503716757 -0.13856533  0.05843040  0.25542613  0.4524219
[3,] 0.2600591  0.333077590  0.89399146 -0.09282033 -0.07963211 -0.0664439
[4,] 0.3412783  0.162438422 -0.10083382  0.88313920 -0.13288779 -0.1489148
[5,] 0.4224975 -0.008200745 -0.09565910 -0.14090128  0.81385653 -0.2313857
[6,] 0.5037168 -0.178839912 -0.09048437 -0.16494176 -0.23939915  0.6861435
[7,] 0.5849360 -0.349479080 -0.08530965 -0.18898224 -0.29265482 -0.3963274
            [,7]
[1,] -0.26627839
[2,]  0.64941759
[3,] -0.05325568
[4,] -0.16494176
[5,] -0.27662784
[6,] -0.38831392
[7,]  0.50000000

$vt
          [,1]       [,2]
[1,] 0.1979452  0.9802131
[2,] 0.9802131 -0.1979452

> stopifnot(dim(s$u) == c(7,7))
> La.svd(X, nv = 0)
$d
[1] 12.068734  1.160022

$u
          [,1]         [,2]
[1,] 0.0976207  0.674355925
[2,] 0.1788399  0.503716757
[3,] 0.2600591  0.333077590
[4,] 0.3412783  0.162438422
[5,] 0.4224975 -0.008200745
[6,] 0.5037168 -0.178839912
[7,] 0.5849360 -0.349479080

> 
> # test of complex case
> 
> X <- cbind(1, 1:7+(-3:3)*1i)
> str(s <- La.svd(X)); D <- diag(s$d)
List of 3
 $ d : num [1:2] 13.14  1.51
 $ u : cplx [1:7, 1:2] 0.088-0.225i 0.163-0.150i 0.238-0.075i ...
 $ vt: cplx [1:2, 1:2] 0.167+0i 0.986+0i 0.986+0i ...
> stopifnot(abs(X - s$u %*% D %*% s$vt) < Eps)
> stopifnot(abs(D - Conj(t(s$u)) %*% X %*% Conj(t(s$vt))) < Eps)
> 
> # in this case svd calls La.svd
> str(s <- svd(X)); D <- diag(s$d)
List of 3
 $ d: num [1:2] 13.14  1.51
 $ u: cplx [1:7, 1:2] 0.088-0.225i 0.163-0.150i 0.238-0.075i ...
 $ v: cplx [1:2, 1:2] 0.167+0i 0.986+0i 0.986+0i ...
> stopifnot(abs(X - s$u %*% D %*% Conj(t(s$v))) < Eps)
> stopifnot(abs(D - Conj(t(s$u)) %*% X %*% s$v) < Eps)
> 
> 
> 
> ##  -------  tests of random real and complex matrices ------
> 
> ##			       100  may cause failures here.
> eigenok <- function(A, E, Eps=1000*.Machine$double.eps)
+ {
+     V <- E$vect; lam <- E$values
+     stopifnot(abs(A %*% V - V %*% diag(lam)) < Eps,
+               abs(lam[length(lam)]/lam[1]) < Eps || # this one not for singular A :
+               abs(A - V %*% diag(lam) %*% t(V)) < Eps)
+ }
> 
> Ceigenok <- function(A, E, Eps=1000*.Machine$double.eps)
+ {
+     V <- E$vect; lam <- E$values
+     stopifnot(Mod(A %*% V - V %*% diag(lam)) < Eps,
+               Mod(A - V %*% diag(lam) %*% Conj(t(V))) < Eps)
+ }
> 
> ## failed for some 64bit-Lapack-gcc combinations:
> sm <- cbind(1, 3:1, 1:3)
> eigenok(sm, eigen(sm))
> eigenok(sm, eigen(sm, sym=FALSE))
> 
> set.seed(123)
> sm <- matrix(rnorm(25), 5, 5)
> sm <- 0.5 * (sm + t(sm))
> eigenok(sm, eigen(sm))
> eigenok(sm, eigen(sm, sym=FALSE))
> 
> sm[] <- as.complex(sm)
> Ceigenok(sm, eigen(sm))
> Ceigenok(sm, eigen(sm, sym=FALSE))
> 
> sm[] <- sm + rnorm(25) * 1i
> sm <- 0.5 * (sm + Conj(t(sm)))
> Ceigenok(sm, eigen(sm))
> Ceigenok(sm, eigen(sm, sym=FALSE))
> 
